# -*- coding: utf-8 -*-
"""MEDHW1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yENSzdjPwrPA9oKO5wqOMhg7epMePP1T
"""

import numpy as np
import matplotlib.pyplot as plt

"""# 1. Generate signals	and	plots	in	time	domain

<h2>(a):</h2>
"""

# 1− exp(−t /T1 ) , 0 ≤ t ≤ 6000, T1 = 1000
Sample_a = 1000 
Time_a, Step_a = np.linspace(start=0, stop=6000, num=Sample_a, endpoint=True, retstep=True)
sig_a = 1 - np.exp(-Time_a/1000)

plt.figure(figsize=(8,4)) #擴大subplot畫面
plt.subplot()
plt.plot(Time_a, sig_a)

plt.title('a')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['Signal a'])

"""<h2>(b):</h2>

"""

# exp(−t /T2 ) , 0 ≤ t ≤ 500 , T2 = 60
Sample_b = 500 
Time_b, Step_a = np.linspace(start=0, stop=500, num=Sample_b, endpoint=True, retstep=True)
sig_b = np.exp(-Time_b/60)

plt.figure(figsize=(8,4)) #擴大subplot畫面
plt.subplot()
plt.plot(Time_b, sig_b)

plt.title('b')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['Signal b'])

"""<h2>(c):</h2>

"""

# cos(200πt +10π) , 0 ≤ t ≤ 20 msec , fs = 250Hz
Sample_c = int(0.02*250)+1 
Time_c, Step_c = np.linspace(start=0, stop=0.02, num=Sample_c, endpoint=True, retstep=True)
sig_c = np.cos(200*np.pi*Time_c+10*np.pi)

plt.figure(figsize=(8,4)) #擴大subplot畫面
plt.subplot()
plt.plot(Time_c, sig_c)

plt.title('c')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['Signal c'])

"""<h2>(d):</h2>"""

# cos(200πt +10π) , 0 ≤ t ≤ 20 msec , fs = 100Hz
Sample_d = int(0.02*100)+1 
Time_d, Step_d = np.linspace(start=0, stop=0.02, num=Sample_d, endpoint=True, retstep=True)
sig_d = np.cos(200*np.pi*Time_d+10*np.pi)

plt.figure(figsize=(8,4)) #擴大subplot畫面
plt.subplot()
plt.plot(Time_d, sig_d)

plt.title('d')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['Signal d'])

"""<h2>(e):</h2>"""

# sin(200πt)/πt , −100 ≤ t ≤100 msec, fs = 400Hz
Sample_e = int(0.2*400)+1
Time_e, Step_e = np.linspace(start=-0.1, stop=0.1, num=Sample_e, endpoint=True, retstep=True)
sig_e = np.sin(200*np.pi*Time_e) / (np.pi*Time_e)

plt.figure(figsize=(8,4)) #擴大subplot畫面
plt.subplot()
plt.plot(Time_e, sig_e)

plt.title('e')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['Signal e'])

"""## 2. Fourier transformed(c、d、e)"""

# c
# cos(200πt +10π) , 0 ≤ t ≤ 20 msec , fs = 250Hz
#Sample_c = int(0.02*250)+1 
#Time_c, Step_c = np.linspace(start=0, stop=0.02, num=Sample_c, endpoint=True, retstep=True)
#sig_c = np.cos(200*np.pi*Time_c+10*np.pi)
Sample_c_2 = int(0.02*250)+1
Time_c_2, Step_c_2 = np.linspace(start=0, stop=0.02, num=Sample_c_2, retstep=True)
sig_c_2 = np.cos(200*np.pi*Time_c_2+10*np.pi)
for_c = np.fft.fft(sig_c_2)
shift_c = np.fft.fftshift(np.fft.fftfreq(len(Time_c_2),d=Step_c_2))#調整，使0為數據中心點

plt.figure(figsize=(15,4)) #擴大subplot畫面
plt.subplot()
plt.plot(shift_c,np.abs(np.fft.fftshift(for_c)))

plt.title('c')
plt.xlabel('Frequency')
plt.ylabel('Magnitude')
plt.legend(['Signal c'])

# cos(200πt +10π) , 0 ≤ t ≤ 20 msec , fs = 100Hz
#Sample_d = int(0.02*100)+1 
#Time_d, Step_d = np.linspace(start=0, stop=0.02, num=Sample_d, endpoint=True, retstep=True)
#sig_d = np.cos(200*np.pi*Time_d+10*np.pi)

Sample_d_2 = int(100*0.02)+1
Time_d_2, Step_d_2 = np.linspace(start=0, stop=0.02, num=Sample_d_2, retstep=True)
sig_d_2 = np.cos(200*np.pi*Time_d_2+10*np.pi)
for_d = np.fft.fft(sig_d_2)
shift_d = np.fft.fftshift(np.fft.fftfreq(len(Time_d_2),d=Step_d_2))#調整，使0為數據中心點

plt.figure(figsize=(15,4)) #擴大subplot畫面
plt.subplot()
plt.plot(shift_d,np.abs(np.fft.fftshift(for_d)))

plt.title('d')
plt.xlabel('Frequency')
plt.ylabel('Magnitude')
plt.legend(['Signal d'])

# sin(200πt)/πt , −100 ≤ t ≤100 msec, fs = 400Hz
#Sample_e = int(0.2*400)+1
#Time_e, Step_e = np.linspace(start=-0.1, stop=0.1, num=Sample_e, endpoint=True, retstep=True)
#sig_e = np.sin(200*np.pi*Time_e) / (np.pi*Time_e)
Sample_e_2 = int(400*0.2)
Time_e_2, Step_e_2 = np.linspace(start=-0.1, stop=0.1, num=Sample_e_2, retstep=True)
sig_e_2 = np.sin(200*np.pi*Time_e_2) / (np.pi*Time_e_2)
for_e = np.fft.fft(sig_e_2)
shift_e = np.fft.fftshift(np.fft.fftfreq(len(Time_e_2),d=Step_e_2))#調整，使0為數據中心點

plt.figure(figsize=(15,4)) #擴大subplot畫面
plt.subplot()
plt.plot(shift_e,np.abs(np.fft.fftshift(for_e)))

plt.title('e')
plt.xlabel('Frequency')
plt.ylabel('Magnitude')
plt.legend(['Signal e'])

"""## 3. Convolve	the	time-domain	signals	in (c)	with (e)"""

Time_c_3, Step_c_3 = np.linspace(start=0, stop=0.02, num=80, retstep=True)
sig_c_3 = np.cos(200*np.pi*Time_c_3+10*np.pi)
for_c_3 = np.fft.fft(sig_c_3)

Time_e_3, Step_e_3 = np.linspace(start=-0.1, stop=0.1, num=80, retstep=True)
sig_e_3 = np.sin(200*np.pi*Time_e_3) / (np.pi*Time_e_3)
for_e_3 = np.fft.fft(sig_e_3)


sig_cov = np.convolve(sig_c_3,sig_e_3,mode='same')
for_mul = for_c_3 * for_e_3
sig_mul = sig_c_3 * sig_e_3

shift_3 = np.fft.fftshift(np.fft.fftfreq(len(Time_e_3),d=Step_e_3))#調整，使0為數據中心點

sig_cov_fft = np.convolve(for_c_3,for_e_3,mode='same')
sig_cov_ifft = np.fft.ifft(sig_cov_fft)
sigg_ifft = np.fft.ifft(for_mul)

plt.figure(figsize=(12,25)) #擴大subplot畫面
plt.subplot(5,1,1)
plt.plot(Time_e_3,np.abs(sig_cov))
plt.title('conv(c,e)')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')


plt.subplot(5,1,2)
plt.plot(shift_3,np.abs(np.fft.fftshift(sig_cov_fft)))

plt.xlabel('Frequency')
plt.ylabel('Magnitude')
plt.legend(['fft(conv(c,e))'])

plt.subplot(5,1,3)
plt.plot(Time_e_3,np.abs(np.fft.fftshift(sig_cov_ifft)))
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['ifft(fft(conv(c,e)))'])

plt.subplot(5,1,4)
plt.plot(shift_3,np.abs(np.fft.fftshift(sig_mul)))
plt.title('forc * fore')
plt.xlabel('Frequency')
plt.ylabel('Magnitude')


plt.subplot(5,1,5)
plt.plot(Time_e_3,np.abs(sigg_ifft))
plt.title('ifft(forc * fore)')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')

"""# 4. 	plot	time	domain	signal	with	2	side-lobes	and	6	side-lobes """

# sin(200πt)/πt , −100 ≤ t ≤100 msec, fs = 400Hz

Time_e_4, Step_e_4 = np.linspace(start=-0.1, stop=0.1, num=200, retstep=True)
sig_e_4 = np.sin(200*np.pi*Time_e_4) / (np.pi*Time_e_4)
sig_e_4_2 = np.sin(35*np.pi*Time_e_4) / (np.pi*Time_e_4)
fft_sig_e_4_2 = np.fft.fft(sig_e_4_2)

shift_4 = np.fft.fftshift(np.fft.fftfreq(len(Time_e_4),d=Step_e_4))

sig_e_4_6 = np.sin(75*np.pi*Time_e_4) / (np.pi*Time_e_4)
fft_sig_e_4_6 = np.fft.fft(sig_e_4_6)

plt.figure(figsize=(15,8)) #擴大subplot畫面

plt.subplot(511)
plt.plot(Time_e_4, sig_e_4)
plt.title('e')
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['Signal e'])

plt.subplot(512)
plt.plot(Time_e_4, sig_e_4_2)
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['two lobes'])

plt.subplot(513)
plt.plot(shift_4,np.abs(np.fft.fftshift(fft_sig_e_4_2)))
plt.xlabel('Frequency')
plt.ylabel('Magnitude')
plt.legend(['two lobes'])

plt.subplot(514)
plt.plot(Time_e_4, sig_e_4_6)
plt.xlabel('Time(s)')
plt.ylabel('Amplitude')
plt.legend(['six lobes'])

plt.subplot(515)
plt.plot(shift_4,np.abs(np.fft.fftshift(fft_sig_e_4_6)))
plt.xlabel('Frequency')
plt.ylabel('Magnitude')
plt.legend(['six lobes'])

"""# 5. plot	the	following	2-D	functions	as	gray-level	images"""

pixels = np.zeros((512,512))
pixels2 = np.zeros((512,512))

for i in range(1,513):
  for j in range(1,513):
    pixels[i-1][j-1] = np.cos(2 * np.pi * (i + 2 * j))

pixels_fft = np.fft.fft2(pixels)
shift_5_1 = np.fft.fftshift(pixels_fft)
res = (np.abs(shift_5_1))

for i in range(1,513):
  for j in range(1,513):
    pixels2[i-1][j-1] = ((np.sin(4 * np.pi * i))/(np.pi * i)) * ((np.sin(2 * np.pi * j))/(np.pi * j))


pixels_fft_2 = np.fft.fft2(pixels2)
shift_5_2 = np.abs(np.fft.fftshift(pixels_fft_2))
res_2 = np.log(shift_5_2)

# creating a plot
plt.figure(figsize=(20,20))
# plotting a plot
#pixel_plot.add_axes()
  
# customizing plot
plt.subplot(411)
plt.title("pixel_plot")
pixel_plot = plt.imshow(pixels,cmap='gray', vmin=0, vmax=1)
plt.colorbar(pixel_plot)

plt.subplot(412)
plt.title("pixel_plot_1_fft")
pixel_plot_2 = plt.imshow(res,cmap='gray', vmin=0, vmax=1)
plt.colorbar(pixel_plot_2)



plt.subplot(413)
plt.title("pixel_plot_2")
pixel_plot_3 = plt.imshow(pixels2,cmap='gray', vmin=0, vmax=1)
plt.colorbar(pixel_plot_3)

plt.subplot(414)
plt.title("pixel_plot_2_fft")
pixel_plot_4 = plt.imshow(res_2,cmap='gray', vmin=0, vmax=1)
plt.colorbar(pixel_plot_4)

"""# 6. 	2D	Gaussian	function"""

# center = 512 / 2 = 256, σ = 10
A = 1
pixels_6 = np.zeros((512,512))
for i in range(1,513):
  for j in range(1,513):
    pixels_6[i-1][j-1] = A * np.exp(-((((i-256)*(i-256))/(2*100))+(((j-256)*(j-256))/(2*100))))

plt.title("pixel_plot_6")
pixel_plot_6 = plt.imshow(pixels_6,cmap='gray', vmin=0, vmax=1)
plt.colorbar(pixel_plot_6)